// Copyright 2019 - 2022 The Samply Community
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package fhir

import (
	"encoding/json"
	"fmt"
	"strings"
)

// THIS FILE IS GENERATED BY https://github.com/samply/golang-fhir-models
// PLEASE DO NOT EDIT BY HAND

// AssertionManualCompletionType is documented here http://hl7.org/fhir/ValueSet/assert-manual-completion-codes
type AssertionManualCompletionType int

const (
	AssertionManualCompletionTypeFail AssertionManualCompletionType = iota
	AssertionManualCompletionTypePass
	AssertionManualCompletionTypeSkip
	AssertionManualCompletionTypeStop
)

func (code AssertionManualCompletionType) MarshalJSON() ([]byte, error) {
	return json.Marshal(code.Code())
}
func (code *AssertionManualCompletionType) UnmarshalJSON(json []byte) error {
	s := strings.Trim(string(json), "\"")
	switch s {
	case "fail":
		*code = AssertionManualCompletionTypeFail
	case "pass":
		*code = AssertionManualCompletionTypePass
	case "skip":
		*code = AssertionManualCompletionTypeSkip
	case "stop":
		*code = AssertionManualCompletionTypeStop
	default:
		return fmt.Errorf("unknown AssertionManualCompletionType code `%s`", s)
	}
	return nil
}
func (code AssertionManualCompletionType) String() string {
	return code.Code()
}
func (code AssertionManualCompletionType) Code() string {
	switch code {
	case AssertionManualCompletionTypeFail:
		return "fail"
	case AssertionManualCompletionTypePass:
		return "pass"
	case AssertionManualCompletionTypeSkip:
		return "skip"
	case AssertionManualCompletionTypeStop:
		return "stop"
	}
	return "<unknown>"
}
func (code AssertionManualCompletionType) Display() string {
	switch code {
	case AssertionManualCompletionTypeFail:
		return "Fail"
	case AssertionManualCompletionTypePass:
		return "Pass"
	case AssertionManualCompletionTypeSkip:
		return "Skip"
	case AssertionManualCompletionTypeStop:
		return "Stop"
	}
	return "<unknown>"
}
func (code AssertionManualCompletionType) Definition() string {
	switch code {
	case AssertionManualCompletionTypeFail:
		return "Mark the currently waiting test failed and proceed with the next assert if the stopTestOnFail is false or the next test in the TestScript if the stopTestOnFail is true."
	case AssertionManualCompletionTypePass:
		return "Mark the currently waiting test passed (if the test is not failed already) and proceed with the next action in the TestScript."
	case AssertionManualCompletionTypeSkip:
		return "Mark this assert as skipped and proceed with the next action in the TestScript."
	case AssertionManualCompletionTypeStop:
		return "Stop execution of this TestScript. The overall status of this TestScript is evaluated based on the status of the completed tests."
	}
	return "<unknown>"
}
